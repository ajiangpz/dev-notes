---
title: 用最少数量的箭引爆气球
date: "2025-03-26"
tags: ["algorithm", "greedy"]
draft: false
summary:
---

## 用最少数量的箭引爆气球

## 题目描述

    在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。

    一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出任意数量的箭，弓箭一旦被射出之后，可以到达的任意 x 轴上的点都应该被考虑在内。

    给定一个数组 `points` ，其中 `points[i] = [xstart, xend]` 表示气球直径的开始和结束坐标。最多可以射出多少支箭？

## 示例

    输入: points = [[10,16],[2,8],[1,6],[7,12]]
    输出: 2
    解释: 对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球。

## 解题思路

    这个问题可以看作是：

    1. 找到最多不重叠的区间
    2. 计算需要射出的箭的数量

    具体来说，我们可以先按照区间的结束位置排序，然后遍历区间，如果当前区间的开始位置大于上一支箭的位置，则需要新的箭，否则更新上一支箭的位置。

## 代码实现

```javascript
var findMinArrowShots = function(points) {
    if (points.length === 0) return 0;
    
    // 按照区间结束位置排序
    points.sort((a, b) => a[1] - b[1]); 
    
    let arrows = 1;  // 至少需要一支箭
    let end = points[0][1];  // 第一支箭的位置
    
    for (let i = 1; i < points.length; i++) {
        // 如果当前气球的开始位置大于上一支箭的位置，则需要新的箭
        if (points[i][0] > end) {   
            arrows++;
            end = points[i][1];  // 更新箭的位置
        }
    }
    
    return arrows;
};  
```

## 复杂度分析

    时间复杂度：O(n log n)，其中 n 是区间的数量。排序的时间复杂度为 O(n log n)，遍历区间的复杂度为 O(n)。
    空间复杂度：O(1)，我们只需要常数空间来存储箭的数量和结束位置。  

## 解题总结

    这个问题是一个典型的贪心算法问题，通过排序和遍历来找到最多的不重叠区间，从而计算出需要射出的箭的数量。

    贪心算法是一种在每一步选择中都采取在当前状态下最好或最优的选择的算法。它通过一系列局部最优的选择，期望能够得到全局最优解。

    在解决这个问题时，我们首先将区间按照结束位置排序，然后遍历区间，如果当前区间的开始位置大于上一支箭的位置，则需要新的箭，否则更新上一支箭的位置。

    这种方法的正确性基于以下两个事实：

    1. 如果我们射出一支箭，那么我们至少可以引爆一个气球。   
    2. 如果我们有多支箭，那么我们可以选择射出尽可能少的箭，从而引爆尽可能多的气球。

    通过这种方式，我们可以确保我们使用的箭数量最少，从而得到全局最优解。

    

    
